#nullable enable
using System;
using System.Collections;
using System.Linq;
using Architecture;
using Core;
using Core.DataManagement;
using Core.WorldData.Data;
using GameplaySystems.Hacking;
using UnityEngine;
using UnityEngine.InputSystem;
using Utility;

namespace UI.PrefabCommands.Netcat
{
	public class ExploitCraftingCommand : CommandScript
	{
		private string? exploitName;
		private string? payloadName;
		private bool showExploitSelect;
		private bool showPayloadSelect;
		private string[] availableExploitNames ;
		private string[] availablePayloadNames;
		private bool hasRun = false;

		[SerializeField]
		private WorldManagerHolder world = null!;

		[SerializeField]
		private HackingHolder hackingSystem = null!;
		
		private void Start()
		{
			if (!hasRun)
				StartCoroutine(Run(showExploitSelect, showPayloadSelect));
			
			hasRun = true;
		}

		/// <inheritdoc />
		protected override void OnMain()
		{
			this.availableExploitNames = hackingSystem.Value.Exploits
				.Select(x => x.Name)
				.Where(x => FileSystem.FileExists(PathUtility.Combine("usr", "lib", "exploits", x)))
				.ToArray();
			this.availablePayloadNames = hackingSystem.Value.Payloads
				.Select(x => x.Name)
				.Where(x => FileSystem.FileExists(PathUtility.Combine("usr", "lib", "payloads", x)))
				.ToArray();
			
			
			showExploitSelect = !TryGetEnvironmentVariable("EXPLOIT", out exploitName);
			showPayloadSelect = !TryGetEnvironmentVariable("PAYLOAD", out payloadName);
		}

		private IEnumerator Run(bool showExploitMenu, bool showPayloadMenu)
		{
			Console.SuppressInput = true;
			
			if (!availableExploitNames.Contains(exploitName))
				showExploitMenu = true;
			
			if (showExploitMenu)
			{
				yield return SelectMenu("Select Exploit", availableExploitNames, x => { this.exploitName = availableExploitNames[x]; });
			}

			ExploitAsset exploit = hackingSystem.Value.Exploits.First(x => x.Name == exploitName);
			if (!exploit.RequiresPayload)
				showPayloadMenu = false;
			else
			{
				if (!availablePayloadNames.Contains(payloadName))
					showPayloadMenu = true;
			}
			
			if (showPayloadMenu)
			{
				yield return SelectMenu("Select Payload", availablePayloadNames, x => { this.payloadName = availablePayloadNames[x]; });
			}

			yield return null;
			Console.SuppressInput = false;
			
			world.Value.World.CraftedExploits.Add(new WorldCraftedExploitData
			{
				InstanceId = world.Value.GetNextObjectId(),
				Computer = ObjectId.Invalid,
				Exploit = exploitName,
				Payload = exploit.RequiresPayload ? payloadName : null,
				FilePath = GetCraftOutputPath()
			});
			
			EndProcess();
		}

		private string GetCraftOutputPath()
		{
			string workingDirectory = this.WorkingDirectory;

			string path = PathUtility.Combine(workingDirectory, exploitName);

			var i = 0;
			while (FileSystem.FileExists(path) || FileSystem.DirectoryExists(path))
			{
				i++;
				path = PathUtility.Combine(workingDirectory, $"{exploitName}_{i}");
			}

			return path;
		}
		
		private IEnumerator SelectMenu(string title, string[] options, Action<int> selectedCallback)
		{
			var exploitSelected = false;
			var selectedIndex = 0;
			var keyboard = Keyboard.current;
			
			bool wasUpPressed = keyboard[Key.UpArrow].IsPressed();
			bool wasDownPressed = keyboard[Key.DownArrow].IsPressed();
			bool wasEnterPressed = keyboard[Key.Enter].IsPressed();

			while (!exploitSelected)
			{
				Console.Clear();
				Console.WriteLine(title);
				for (var i = 0; i < title.Length; i++)
					Console.Write("=");
				Console.WriteLine();
				Console.WriteLine();

				for (var i = 0; i < options.Length; i++)
				{
					if (i == selectedIndex)
						Console.Write("\x1b[101m  ");
					else
						Console.Write("\x1b[0m  ");

					Console.WriteLine(options[i]);
				}
				Console.Write("\x1b[0m");

				bool redraw = false;
				
				while (!redraw)
				{
					bool isDownPressed = keyboard[Key.DownArrow].IsPressed();
					bool isUpPressed = keyboard[Key.UpArrow].IsPressed();
					bool isEnterPressed = keyboard[Key.Enter].IsPressed();

					if (isEnterPressed && !wasEnterPressed)
					{
						selectedCallback?.Invoke(selectedIndex);
						yield break;
					}
					
					if (isDownPressed && !wasDownPressed)
					{
						if (selectedIndex < options.Length - 1)
						{
							selectedIndex++;
							redraw = true;
						}
					}

					// starting to feel like fucking yandev with this shitty ass fucking code
					if (isUpPressed && !wasUpPressed)
					{
						if (selectedIndex > 0)
						{
							selectedIndex--;
							redraw = true;
						}
					}

					wasDownPressed = isDownPressed;
					wasUpPressed = isUpPressed;
					wasEnterPressed = isEnterPressed;
					
					yield return null;
				}
			}
		}
	}
}